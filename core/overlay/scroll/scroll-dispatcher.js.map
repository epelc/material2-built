{"version":3,"sources":["../../../../../../src/lib/core/overlay/scroll/scroll-dispatcher.ts"],"names":[],"mappings":"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","file":"scroll-dispatcher.js","sourceRoot":"","sourcesContent":["import {Injectable, ElementRef, Optional, SkipSelf} from '@angular/core';\nimport {Scrollable} from './scrollable';\nimport {Subject} from 'rxjs/Subject';\nimport {Observable} from 'rxjs/Observable';\nimport {Subscription} from 'rxjs/Subscription';\nimport'rxjs/add/observable/fromEvent';\nimport'rxjs/add/observable/merge';\nimport'rxjs/add/operator/auditTime';\n\n\n/** Time in ms to throttle the scrolling events by default. */\nexport const /** @type {?} */ DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nexport class ScrollDispatcher {\n  /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n  _scrolled: Subject<void> = new Subject<void>();\n\n  /** Keeps track of the global `scroll` and `resize` subscriptions. */\n  _globalSubscription: Subscription = null;\nprivate _scrolledCount = 0;\n\n  /**\n   * Map of all the scrollable references that are registered with the service and their\n   * scroll event subscriptions.\n   */\n  scrollableReferences: Map<Scrollable, Subscription> = new Map();\n/**\n * Registers a Scrollable with the service and listens for its scrolled events. When the\n * scrollable is scrolled, the service emits the event in its scrolled observable.\n * @param {?} scrollable Scrollable instance to be registered.\n * @return {?}\n */\nregister(scrollable: Scrollable): void {\n    const /** @type {?} */ scrollSubscription = scrollable.elementScrolled().subscribe(() => this._notify());\n\n    this.scrollableReferences.set(scrollable, scrollSubscription);\n  }\n/**\n * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n * @param {?} scrollable Scrollable instance to be deregistered.\n * @return {?}\n */\nderegister(scrollable: Scrollable): void {\n    if (this.scrollableReferences.has(scrollable)) {\n      this.scrollableReferences.get(scrollable).unsubscribe();\n      this.scrollableReferences.delete(scrollable);\n    }\n  }\n/**\n * Subscribes to an observable that emits an event whenever any of the registered Scrollable\n * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n * to override the default \"throttle\" time.\n * @param {?=} auditTimeInMs\n * @param {?=} callback\n * @return {?}\n */\nscrolled(auditTimeInMs: number = DEFAULT_SCROLL_TIME, callback: () => any): Subscription {\n    // In the case of a 0ms delay, use an observable without auditTime\n    // since it does add a perceptible delay in processing overhead.\n    let /** @type {?} */ observable = auditTimeInMs > 0 ?\n      this._scrolled.asObservable().auditTime(auditTimeInMs) :\n      this._scrolled.asObservable();\n\n    this._scrolledCount++;\n\n    if (!this._globalSubscription) {\n      this._globalSubscription = Observable.merge(\n        Observable.fromEvent(window.document, 'scroll'),\n        Observable.fromEvent(window, 'resize')\n      ).subscribe(() => this._notify());\n    }\n\n    // Note that we need to do the subscribing from here, in order to be able to remove\n    // the global event listeners once there are no more subscriptions.\n    return observable.subscribe(callback).add(() => {\n      this._scrolledCount--;\n\n      if (this._globalSubscription && !this.scrollableReferences.size && !this._scrolledCount) {\n        this._globalSubscription.unsubscribe();\n        this._globalSubscription = null;\n      }\n    });\n  }\n/**\n * Returns all registered Scrollables that contain the provided element.\n * @param {?} elementRef\n * @return {?}\n */\ngetScrollContainers(elementRef: ElementRef): Scrollable[] {\n    const /** @type {?} */ scrollingContainers: Scrollable[] = [];\n\n    this.scrollableReferences.forEach((subscription: Subscription, scrollable: Scrollable) => {\n      if (this.scrollableContainsElement(scrollable, elementRef)) {\n        scrollingContainers.push(scrollable);\n      }\n    });\n\n    return scrollingContainers;\n  }\n/**\n * Returns true if the element is contained within the provided Scrollable.\n * @param {?} scrollable\n * @param {?} elementRef\n * @return {?}\n */\nscrollableContainsElement(scrollable: Scrollable, elementRef: ElementRef): boolean {\n    let /** @type {?} */ element = elementRef.nativeElement;\n    let /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n\n    // Traverse through the element parents until we reach null, checking if any of the elements\n    // are the scrollable's element.\n    do {\n      if (element == scrollableElement) { return true; }\n    } while (element = element.parentElement);\n  }\n/**\n * Sends a notification that a scroll event has been fired.\n * @return {?}\n */\n_notify() {\n    this._scrolled.next();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollDispatcher_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollDispatcher.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollDispatcher.ctorParameters;\n/**\n * Subject for notifying that a registered scrollable reference element has been scrolled.\n * @type {?}\n */\nScrollDispatcher.prototype._scrolled;\n/**\n * Keeps track of the global `scroll` and `resize` subscriptions.\n * @type {?}\n */\nScrollDispatcher.prototype._globalSubscription;\n/**\n * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n * @type {?}\n */\nScrollDispatcher.prototype._scrolledCount;\n/**\n * Map of all the scrollable references that are registered with the service and their\n * scroll event subscriptions.\n * @type {?}\n */\nScrollDispatcher.prototype.scrollableReferences;\n}\n\n/**\n * @param {?} parentDispatcher\n * @return {?}\n */\nexport function SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher: ScrollDispatcher) {\n  return parentDispatcher || new ScrollDispatcher();\n}\n\nexport const /** @type {?} */ SCROLL_DISPATCHER_PROVIDER = {\n  // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n  provide: ScrollDispatcher,\n  deps: [[new Optional(), new SkipSelf(), ScrollDispatcher]],\n  useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}